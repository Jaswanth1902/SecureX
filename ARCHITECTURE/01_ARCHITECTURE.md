# Secure File Printing System - Architecture

## Project Overview
A secure file printing application that encrypts files at the user side, stores them encrypted on the server, and allows the owner to decrypt and print without ever accessing the unencrypted file permanently.

### Key Objectives
1. **Privacy Protection**: User files are encrypted before leaving the user's device
2. **Owner Limitation**: Owner cannot store or view unencrypted files
3. **Automatic Cleanup**: Files are automatically deleted after printing
4. **Secure Communication**: All data transfer is encrypted and authenticated

---

## System Architecture

### Components

#### 1. **User Mobile App (Flutter)**
- Platform: iOS/Android
- Responsibilities:
  - File selection and preview
  - Client-side encryption using AES-256-GCM
  - File upload to server
  - Print job tracking
  - Job history and status monitoring

#### 2. **Owner Windows App (Flutter)**
- Platform: Windows Desktop
- Responsibilities:
  - Authentication and authorization
  - Retrieve encrypted files from server
  - Client-side decryption using AES-256-GCM
  - Print management via Windows Print API
  - Print job history and logging

#### 3. **Backend Server**
- Language: Node.js/Python/C# (recommend Node.js with Express)
- Responsibilities:
  - User/Owner authentication and authorization
  - Encrypted file storage management
  - REST API for file upload/download
  - Print job queue management
  - Audit logging
  - File expiration and cleanup

#### 4. **Database (SQL)**
- Primary: PostgreSQL or SQL Server
- Stores:
  - User and owner account data
  - File metadata (encrypted files)
  - Print jobs and history
  - Session tokens and keys
  - Audit logs

---

## Encryption Flow

### User Side - Upload Process
```
1. User selects file
2. User app generates random symmetric key (256-bit)
3. User app encrypts file with AES-256-GCM
4. User app sends:
   - Encrypted file data
   - Encrypted symmetric key (encrypted with owner's public key - RSA-2048)
   - File metadata
5. User app displays confirmation
```

### Server Side - Storage
```
1. Receive encrypted file and encrypted key
2. Verify user authentication
3. Store encrypted file blob
4. Store encrypted key separately
5. Store file metadata
6. Return job ID to user
```

### Owner Side - Download & Print Process
```
1. Owner retrieves print job from server
2. Server sends:
   - Encrypted file
   - Encrypted symmetric key (encrypted with owner's private RSA key)
3. Owner app decrypts symmetric key using private RSA key
4. Owner app decrypts file using symmetric key
5. Owner app sends to printer
6. Owner app requests server to delete file
7. Server deletes file and encrypted key
```

---

## Key Management Strategy

### Symmetric Key (AES-256)
- **Generated by**: User app (random)
- **Used for**: File encryption/decryption
- **Transmitted**: Encrypted with owner's public RSA key
- **Storage**: Never stored in plaintext on owner's device

### Asymmetric Keys (RSA-2048)
- **Owner Public Key**: Known to users and server
- **Owner Private Key**: Stored securely on owner's Windows device
- **Used for**: Encrypting the symmetric key for secure transmission

### API Keys/Tokens
- **JWT tokens** for API authentication
- **Refresh tokens** for session management
- **HTTPS/TLS** for all communication

---

## Database Schema (PostgreSQL)

### Users Table
```sql
CREATE TABLE users (
  id UUID PRIMARY KEY,
  email VARCHAR(255) UNIQUE NOT NULL,
  password_hash VARCHAR(255) NOT NULL,
  phone VARCHAR(20),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  is_active BOOLEAN DEFAULT true
);
```

### Owners Table
```sql
CREATE TABLE owners (
  id UUID PRIMARY KEY,
  email VARCHAR(255) UNIQUE NOT NULL,
  password_hash VARCHAR(255) NOT NULL,
  public_key TEXT NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  is_active BOOLEAN DEFAULT true
);
```

### Files Table
```sql
CREATE TABLE files (
  id UUID PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  owner_id UUID NOT NULL REFERENCES owners(id),
  encrypted_file_data BYTEA NOT NULL,
  encrypted_symmetric_key BYTEA NOT NULL,
  file_name VARCHAR(255) NOT NULL,
  file_size_bytes BIGINT NOT NULL,
  original_file_hash VARCHAR(64),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  expires_at TIMESTAMP,
  is_deleted BOOLEAN DEFAULT false
);
```

### Print Jobs Table
```sql
CREATE TABLE print_jobs (
  id UUID PRIMARY KEY,
  file_id UUID NOT NULL REFERENCES files(id) ON DELETE CASCADE,
  owner_id UUID NOT NULL REFERENCES owners(id),
  status VARCHAR(50) DEFAULT 'PENDING', -- PENDING, PRINTING, COMPLETED, FAILED
  printer_name VARCHAR(255),
  pages_printed INT,
  print_timestamp TIMESTAMP,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  completed_at TIMESTAMP
);
```

### Audit Log Table
```sql
CREATE TABLE audit_logs (
  id UUID PRIMARY KEY,
  user_id UUID REFERENCES users(id) ON DELETE SET NULL,
  owner_id UUID REFERENCES owners(id) ON DELETE SET NULL,
  action VARCHAR(255) NOT NULL,
  resource_type VARCHAR(50),
  resource_id UUID,
  details JSONB,
  ip_address VARCHAR(45),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

---

## API Endpoints

### User Endpoints

#### 1. User Registration
```
POST /api/users/register
Body: {
  email: string,
  password: string,
  name: string
}
Response: { userId: string, token: string }
```

#### 2. User Login
```
POST /api/users/login
Body: {
  email: string,
  password: string
}
Response: { token: string, refreshToken: string }
```

#### 3. Upload File for Printing
```
POST /api/files/upload
Headers: Authorization: Bearer {token}
Body: FormData {
  encryptedFile: binary,
  encryptedSymmetricKey: binary,
  fileName: string,
  fileSize: number,
  ownerId: string
}
Response: { jobId: string, status: string }
```

#### 4. Get Print Job Status
```
GET /api/jobs/{jobId}
Headers: Authorization: Bearer {token}
Response: {
  jobId: string,
  status: string,
  createdAt: timestamp,
  completedAt: timestamp
}
```

#### 5. Get User's Print History
```
GET /api/jobs/history
Headers: Authorization: Bearer {token}
Response: [{ jobId, status, fileName, createdAt, completedAt }]
```

---

### Owner Endpoints

#### 1. Owner Registration
```
POST /api/owners/register
Body: {
  email: string,
  password: string,
  name: string,
  publicKey: string
}
Response: { ownerId: string, token: string }
```

#### 2. Owner Login
```
POST /api/owners/login
Body: {
  email: string,
  password: string
}
Response: { token: string, refreshToken: string }
```

#### 3. Get Pending Print Jobs
```
GET /api/owners/jobs/pending
Headers: Authorization: Bearer {token}
Response: [{ jobId, fileName, fileSize, userId, createdAt }]
```

#### 4. Download Encrypted File
```
GET /api/owners/files/{fileId}
Headers: Authorization: Bearer {token}
Response: {
  encryptedFile: binary,
  encryptedSymmetricKey: binary,
  fileName: string
}
```

#### 5. Mark Print Job as Complete
```
POST /api/owners/jobs/{jobId}/complete
Headers: Authorization: Bearer {token}
Body: {
  printerName: string,
  pagesPrinted: number
}
Response: { status: string, deletedAt: timestamp }
```

#### 6. Get Owner's Print History
```
GET /api/owners/jobs/history
Headers: Authorization: Bearer {token}
Response: [{ jobId, fileName, userId, status, completedAt }]
```

---

## Security Considerations

### 1. **Encryption Standards**
- AES-256-GCM for symmetric encryption (ensures authenticity + confidentiality)
- RSA-2048 for asymmetric encryption
- HMAC-SHA256 for message authentication

### 2. **Communication Security**
- HTTPS/TLS 1.3 for all API calls
- Certificate pinning in mobile apps
- API rate limiting to prevent abuse

### 3. **Authentication & Authorization**
- JWT tokens with 1-hour expiration
- Refresh tokens stored securely
- Role-based access control (RBAC)
- Multi-factor authentication (MFA) recommended

### 4. **Data Protection**
- Database encryption at rest
- Field-level encryption for sensitive data
- Regular security audits and penetration testing

### 5. **Audit & Compliance**
- Complete audit logging of all actions
- Compliance with GDPR/CCPA if applicable
- Data retention policies

### 6. **File Deletion**
- Immediate deletion from database after print completion
- Shredding of file data (overwriting with random data)
- Confirmation of deletion before app closes

---

## Deployment Architecture

### Development Environment
```
- Local Flutter development for mobile/desktop
- Local Node.js server
- Local PostgreSQL database
- HTTPS with self-signed certificates
```

### Production Environment
```
- Flutter apps on App Store/Google Play/Windows Store
- Cloud server (AWS/Azure/GCP)
- Managed database (AWS RDS/Azure SQL)
- CDN for static assets
- Load balancing
- Automated backups and disaster recovery
```

---

## Security Flow Diagram

```
USER SIDE                      SERVER                    OWNER SIDE
┌─────────────────┐           ┌──────────────────┐      ┌────────────────────┐
│ Select File     │           │                  │      │                    │
│       ↓         │           │                  │      │                    │
│ Generate Key    │           │                  │      │                    │
│       ↓         │           │                  │      │                    │
│ Encrypt with AES│           │                  │      │                    │
│       ↓         │           │                  │      │                    │
│ Encrypt Key with│           │                  │      │                    │
│ Owner Pub Key   │           │                  │      │                    │
│       ↓         │           │                  │      │                    │
│    Upload       │────→      │ Store Encrypted  │      │                    │
│       ↓         │           │ File & Key       │      │                    │
│ Confirm Job ID  │←────      │       ↓          │      │                    │
│                 │           │ Queue Job        │      │                    │
│                 │           │                  │      │                    │
│                 │           │                  │  ←───┤ Poll for jobs     │
│                 │           │                  │      │       ↓           │
│                 │           │    Download      │  ←───┤ Get encrypted file│
│                 │           │    Encrypted     │      │       ↓           │
│                 │           │    File & Key    │──→   │ Decrypt Key with  │
│                 │           │                  │      │ Private Key       │
│                 │           │                  │      │       ↓           │
│                 │           │                  │      │ Decrypt File with │
│                 │           │                  │      │ Symmetric Key     │
│                 │           │                  │      │       ↓           │
│                 │           │                  │      │ Send to Printer   │
│                 │           │                  │      │       ↓           │
│                 │           │  Mark Complete   │  ←───┤ Delete File       │
│                 │           │  & Delete        │      │ Confirm Complete  │
│                 │           │       ↓          │      │                   │
│ Update Status   │←────      │ File Deleted     │      │                   │
│                 │           │                  │      │                   │
└─────────────────┘           └──────────────────┘      └────────────────────┘
```

---

## Implementation Timeline

### Phase 1: Backend Setup (2-3 weeks)
- [ ] Project setup and configuration
- [ ] Database schema creation
- [ ] Authentication system
- [ ] File upload/download endpoints
- [ ] Print job management APIs

### Phase 2: User Mobile App (3-4 weeks)
- [ ] Project setup with Flutter
- [ ] UI for login/registration
- [ ] File picker and encryption implementation
- [ ] Upload functionality
- [ ] Job tracking and history

### Phase 3: Owner Windows App (3-4 weeks)
- [ ] Project setup with Flutter Desktop
- [ ] UI for login/registration
- [ ] File download and decryption
- [ ] Windows print integration
- [ ] Job management and history

### Phase 4: Testing & Security (2-3 weeks)
- [ ] Unit and integration testing
- [ ] Security audit and penetration testing
- [ ] Performance testing
- [ ] User acceptance testing

### Phase 5: Deployment (1-2 weeks)
- [ ] Cloud infrastructure setup
- [ ] CI/CD pipeline
- [ ] App store submissions
- [ ] Production deployment

---

## Technology Stack

### Backend
- **Runtime**: Node.js 18+
- **Framework**: Express.js
- **Database**: PostgreSQL 14+
- **Authentication**: JWT, bcrypt
- **Encryption**: crypto (Node.js built-in), tweetnacl.js
- **API**: REST with proper error handling
- **Logging**: Winston or Pino
- **Testing**: Jest, Supertest

### User Mobile App
- **Framework**: Flutter 3.0+
- **State Management**: Provider or Riverpod
- **Local Storage**: Flutter Secure Storage
- **Encryption**: pointycastle, flutter_dotenv
- **HTTP Client**: Dio with certificate pinning
- **File Handling**: file_picker, permission_handler

### Owner Windows App
- **Framework**: Flutter 3.0+ (Desktop)
- **State Management**: Provider or Riverpod
- **Encryption**: pointycastle
- **Printing**: print_plus or native Windows API
- **HTTP Client**: Dio with certificate pinning
- **Local Storage**: flutter_secure_storage

### Database
- **System**: PostgreSQL 14+
- **ORM**: Sequelize or TypeORM (Node.js)
- **Migration**: Flyway or Sequelize migrations
- **Backup**: Automated daily backups

---

## Security Checklists

### Development Checklist
- [ ] OWASP Top 10 compliance
- [ ] Input validation on all endpoints
- [ ] SQL injection prevention (parameterized queries)
- [ ] XSS prevention
- [ ] CSRF protection
- [ ] Secure password hashing (bcrypt with salt)
- [ ] Rate limiting
- [ ] API key management
- [ ] Dependency scanning for vulnerabilities

### Deployment Checklist
- [ ] HTTPS/TLS enabled
- [ ] SSL certificate updated
- [ ] Security headers configured
- [ ] CORS properly configured
- [ ] Database backups verified
- [ ] Audit logging enabled
- [ ] Monitoring and alerting configured
- [ ] Incident response plan in place

---

## Conclusion

This architecture ensures maximum security and privacy by:
1. Encrypting files before transmission from user device
2. Preventing owner from accessing unencrypted files permanently
3. Automatic file deletion after printing
4. Strong cryptographic standards
5. Comprehensive audit logging

The system design balances security with usability and can be deployed at scale.
